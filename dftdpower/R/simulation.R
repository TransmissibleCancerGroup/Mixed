library(rstan)
library(rethinking)

plothist <- function(data, cred = 0.95, titletext = "", xlim = NULL, ylim = NULL) {
    credint = HPDI(data, cred)
    h <- MASS::truehist(data, xlim = xlim, ylim = ylim)
    current_ylim = par("usr")[4]
    line_height = current_ylim / 25
    title(main = titletext)
    segments(credint[1], line_height, credint[2], line_height, lwd = 3)
    points(mean(data), line_height, pch=19, col = "red")
    return(h)
} 

#' Run a power analysis simulation to show the probability of
#' detecting a somatic signature in a sample of mutations, when
#' the proportion of somatic mutations is known
#' @param proportion The proportion of somatic mutations in the simulation
#' @param mutations The total number of mutations (germline and somatic combined)
#' @param signatures A data frame or a matrix with the germline signature in
#' column 1 and the somatic signature in column 2
#' @param outerloop The number of outer loop iterations to run. Each iteration of the
#' outer loop simulates a new set of mutations with the given somatic proportion.
#' @param stan.iter The total number of samples generated by the Bayesian model 
#' per chain, per outer loop iteration. Warmup samples are discarded, so stan.iter
#' must be greater than stan.warmup
#' @param stan.chains The number of chains sampled by the Bayesian model
#' @param stan.warmup The number of samples discarded by each chain as warmup/burnin
#' @param credint The width of the credible interval used to generate statistics
#' @useDynLib dftdpower, .registration = TRUE 
#' @importFrom "rstan" extract
#' @importFrom "rstan" sampling
#' @importFrom "rethinking" HPDI
#' @importFrom "MASS" truehist
#' @export
run <- function(proportion, mutations, signatures, outerloop = 100, stan.iter = 2000, stan.chains = 1, stan.warmup = 1000,
                credint = 0.9) {

    if (is.data.frame(signatures)) {
        signatures <- as.matrix(signatures)
    }
    
    if (stan.iter <= stan.warmup) {
        stop("Required: stan.iter > stan.warmup")
    }
    
    # Precompute size of results based on number of outer loop iterations and number of stan iterations
    total_samples = outerloop * stan.chains * (stan.iter - stan.warmup)
    
    # Preallocate matrix to store samples
    alt = matrix(0, nrow = outerloop, 
                 ncol = (stan.chains*(stan.iter-stan.warmup)))
    
    null = matrix(0, nrow = outerloop, 
                  ncol = (stan.chains*(stan.iter-stan.warmup)))
    
    for (i in 1:outerloop) {
        # Generate some data - mycounts has *some* somatic proportion
        #                      and mynull has *no* somatic proportion
        cat(sprintf("Iteration: %d\n", i))
        mycounts <- simulate_multinom(mutations, proportion, signatures)
        mynull <- rmultinom(1, mutations, signatures[,1])
        mycounts[mycounts < 0] <- 0
        mynull[mynull < 0] <- 0
        dat <- list(signatures = signatures, counts = as.vector(mycounts))
        nulldat <- list(signatures = signatures, counts = as.vector(mynull))
        
        # Sample from the null and alternative models
        model <- stanmodels$model
        mcmcsamples <- rstan::sampling(model, data = dat, chains = stan.chains, 
                                       iter = stan.iter, warmup = stan.warmup, 
                                       show_messages = FALSE, open_progress = FALSE, verbose = FALSE,
                                       refresh = 0)
        nullsamples <- rstan::sampling(model, data = nulldat, chains = stan.chains, 
                                       iter = stan.iter, warmup = stan.warmup,
                                       show_messages = FALSE, open_progress = FALSE, verbose = FALSE,
                                       refresh = 0)
        
        alt[i,] <- as.vector(rstan::extract(mcmcsamples, pars = "proportion_somatic")$proportion_somatic)
        null[i,] <- as.vector(rstan::extract(nullsamples, pars = "proportion_somatic")$proportion_somatic)
    }
    
    # Collect samples
    alt.v <- sample(as.vector(alt), total_samples)
    null.v <- sample(as.vector(null), total_samples)
    
    # Compute statistics
    hpdi.null <- HPDI(null.v, credint)
    hpdi.alt <- HPDI(alt.v, credint)
    hpdi.diff <- HPDI(alt.v - null.v, credint)
    
    alt.gt.HPD <- mean(alt.v > hpdi.null) # What proportion of alt is above the 95% upper HPD of null?
    diff.gt.0 <- mean(alt.v - null.v > 0)
    
    # Plot histograms
    par(mfrow = c(1,1))
    MASS::truehist(null.v)
    plotyrange <- par("usr")[3:4]
    plotxrange <- c(min(0, HPDI(alt.v-null.v, 0.995)[1]), HPDI(alt.v, 0.995)[2])  # put all hists on a common x-axis range
    par(mfrow = c(3,1))
    print(
        plothist(alt.v, credint, 
                 sprintf("alt :- Estimate of p when true value is %0.2f", proportion),
                 xlim = plotxrange, ylim = plotyrange))
    print(
        plothist(null.v, credint, 
                 "null :- Estimate of p when true value is 0",
                 xlim = plotxrange, ylim = plotyrange))
    print(
        plothist(alt.v - null.v, credint, 
                 sprintf("alt - null > 0 = %0.3f", diff.gt.0),
                 xlim = plotxrange, ylim = plotyrange))
    par(mfrow = c(1,1))
    
    # Write out statistics
    cat(sprintf("Germline 95%% HPDI = %0.3f, %0.3f\n", hpdi.null[1], hpdi.null[2]))
    cat(sprintf("Somatic 95%% HPDI = %0.3f, %0.3f\n", hpdi.alt[1], hpdi.alt[2]))
    cat(sprintf("Somatic - Germline 95%% HPDI = %0.3f, %0.3f\n", hpdi.diff[1], hpdi.diff[2]))
    cat(sprintf("Prob. that (somatic - germline) > 0 = %0.3f\n", diff.gt.0))
    cat(sprintf("Prob. that somatic > germline upper 95%% HPDI\ = %0.3f\n", alt.gt.HPD))
    cat(paste("Mutations:", round(proportion * mutations), "somatic,", mutations - round(proportion * mutations), "germline"))
    list(hpdi_null = hpdi.null, hpdi_alt = hpdi.alt, hpdi_diff = hpdi.diff,
         diff_gt_0 = diff.gt.0, alt_gt_HPD = alt.gt.HPD, 
         mutations = list(somatic = round(proportion * mutations), germline = mutations - round(proportion * mutations)))
}
